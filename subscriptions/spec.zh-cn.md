# CloudEvents 订阅 API - 0.1 wip 版本

文档语言: [English](spec.md) | [简体中文](spec.zh-cn.md)

## 文摘

该规范为 CNCF 定义了包括 API 定义在内的机制
CloudEvents 事件消费者订阅源自事件的事件
生产者代表事件源。处理这些的软件实体
订阅和负责分发事件被抽象地提到作为“订阅管理器”。

## 1. 简介

可以驻留负责特定事件集的订阅管理器
紧挨着事件生成器或靠近事件生成器，也可以驻留在某些中间件中
基础设施。本文档没有形式化
原始事件生成器和订阅管理器，以及如何订阅
Manager 获取它分发给订阅者的事件。

此文档也没有形式化特定集合之间的关系
事件和订阅管理器。产生多个事件的事件生成器
不同类型的事件可以为所有事件提供一个订阅管理器或一个
每种类型的事件或任何其他组合的订阅管理器。一个事件
生产者也可以提供相同的事件集订阅在多个
并发订阅管理器。不管事件之间的关系如何
生产者和订阅管理者，广告的
订阅服务在 CloudEvents Discovery 服务中发布。

与核心的 CloudEvents 规范一样，该规范的目标是
重用基于现有标准和约定的机制
只在需要的时候引入新的机制。

因此，该规范不仅定义了一个新的订阅管理 API
对于某些用例，还可指现有机制中可用的
存在 CloudEvents 绑定的传输协议的规范。

例如，引入并强制执行特定于 cloudevents 的订阅
MQTT 机制只会使实现复杂化，而不会提供任何实现
明显的优势。的任何引用的本机订阅机制
因此，各自的传输协议是在范围内和在
符合本规范。

## 2. 符号和术语

### 符号约定

关键词“必须”，“不可以”，“要求”，“应该”，“不可以”，“应该”，
“不应该”、“建议”、“可能”和“可选”在本文档中是
解释见[RFC 2119](https://tools.ietf.org/html/rfc2119)。

### 术语

本规范使用了以下术语:

#### Source

事件源是系统中事件所代表的逻辑实体
根据事件产生。

#### Producer

产生事件的实体。事件可能反映了某一事件的发生
来源系统中的其他地方。生产者是创造的具体实体
并发送与某个事件相关的事件。

#### Intermediary

的事件的“中介”(也称为中间件)接收事件
转发到下一个接收者的目的，这可能是另一个
中介或消费者。中介的一个典型任务是路由
根据事件上下文中的信息向接收者发送事件。

#### Consumer

接收和处理事件的实体。的事件
生产者直接或通过中介。消费者可能会听并等待
事件交付给它，或者它可能主动地向生产者请求事件
或中介。

#### Subscription

在消费者和生产者或中介之间建立的关系。
订阅反映了消费者对接收事件和的兴趣
描述如何传递这些事件的方法。

#### Subscription Manager

一个实体，在本规范中定义，它管理对象的生命周期
订阅，并将事件分发给
注册的消费者。

## 3. 事件订阅

该规范定义了 CNCF CloudEvents 事件消费者的机制订阅代表事件源由生产者发起的事件。的
处理这些订阅并负责分发的软件实体
Events 抽象地称为“订阅管理器”。

兼容的 CloudEvents 订阅管理器必须至少支持其中一种
的传输协议，它必须实现
本规范中引用或定义的订阅机制。

在某些情况下，事件生产者可以委托订阅的角色
经理发送给某个中介，在这种情况下产生的事件是可用的
到中介，而中介的订阅管理器决定谁
接收已发布事件的副本。在其他情况下，事件生产者 MAY
自己承担订阅管理器角色。

在这个规范中，我们区分了两个类型的关系
事件消费者和订阅管理器，其中关键的区别是如何启动到消费者的事件传递通道:

- 配置了用户请求交付的订阅(“拉”样式)
  在订阅管理器上，以便通过通信传递事件
  通道(如 AMQP 链接或 MQTT 连接)由使用者和
  连接到订阅管理器。这些类型的订阅是
  通常由消息传递或事件中间件及其生命周期提供
  受通信通道生命周期的限制。

- 订阅管理器发起的交付(“推送”风格)的订阅是在订阅管理器上配置，以便通过
  事件发生时订阅管理器发起的通信通道
  可通过订阅交付。这种结构的结构
  subscription 必须包含订阅管理器所需的所有信息
  要选择传输协议，建立所需的通信通道，
  并交付事件。

使用 CloudEvents 的端到端解决方案可能只使用这些样式中的一种或一种
的组合。

例如，解决方案可能使用 MQTT 代理来处理事件的传递
连接到连接到代理并在上订阅的连接设备
特定的 MQTT 主题，它在某种意义上充当订阅管理器
这个规范(“拉动式”风格)。那些应该分享给
然而，连接的设备可能起源于整个解决方案中的其他地方，并且
因此，一些事件路由器中间件的订阅管理器可能是
配置为将事件(“推送”样式)初始化到给定的 MQTT 中
代理主题，只要此类事件可用。

### 3.1 本机订阅管理机制

MQTT、AMQP、NATS 和 Apache Kafka 都是带有正式 CloudEvents 的协议
具有本机机制填充订阅管理器角色的绑定。

使用任何这些订阅管理机制都应该允许
声明符合本规范的申请书。更具体地说,一个
使用 MQTT 或 AMQP 消息代理作为其中间件组件的应用程序
应该能够使用那些协议的本机功能来订阅
CloudEvents 事件流不需要 CloudEvents Subscription
特定于 api 的机制或扩展。本文档的一致性部分
正式地列举需求。

本节对协议订阅机制的描述如下
非规范化。请参阅协议规范或文档规范 definitions.\_

#### 3.1.1. MQTT 3.x/5.x

MQTT 3.x /5.x 协议有一个原生的“SUBSCRIBE”(和匹配的“UNSUBSCRIBE”)
操作，该操作允许使用者请求匹配模式的消息
针对 MQTT 代理的主题路径层次结构。

MQTT 使用者发出一个或多个 SUBSCRIBE 请求后，进行匹配
任何 MQTT 会话的活动订阅的事件都是由
代理到消费者，而不需要进一步的交互。根据
服务质量(QoS)级别的订阅，个别交付可能
必须得到消费者的认可。

订阅的生存期受 MQTT 会话的生存期限制。
在进入主题的路径上使用“PUBLISH”操作发布事件
层次结构，以及其主题过滤器与路径匹配的所有当前订阅
接收一条消息的规范定义了这些操作

[MQTT 3.1.1](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html) 和
[MQTT 5.0](http://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html)
规范。

#### 3.1.2. AMQP 1.0

AMQP 1.0 协议有一个内置的订阅机制。

当一个 AMQP 容器建立到另一个容器的接收角色链接时，它可以在另一个容器中的链接源上指定“分发模式”。

如果分发方式为“拷贝”，每一个这样建立的链接都收到一份拷贝在分发节点上可用的消息流。

如果分配模式是“移动”，消息是独家拥有的链接，并从来源时，传输已成功解决。

的底层实现支持“复制”模式，是可选的代理链接源还可以配置过滤器。

AMQP 核心规范
没有定义具体的过滤器类型，但是 AMQP 过滤器表达式 1.0
扩展规范和 Apache Qpid 项目的过滤器定义是这样的。

#### 3.1.3.NATS

NATS 协议有一个本地订阅操作“SUB”(和匹配的“不明嫌犯”)，
它允许客户端请求与给定主题匹配的消息流
或一个通配符。

使用带有主题名的“PUB”操作发布事件
与现有订阅相匹配。

#### 3.1.4。Apache Kafka

Apache Kafka 允许使用者获取存储在主题分区中的事件一次或一次很多次了。

虽然 Apache Kafka 没有服务器端订阅操作，但也有不提供过滤功能，它允许抓取客户端完全控件，从中读取分区日志存储事件中的偏移量从对象中检索相同的事件集流。

订阅的管理和选择要获取的事件和分配到应用程序中的完全取决于 Apache Kafka。

#### 3.1.5.HTTP

HTTP 没有允许的内置订阅机制

建立类似于上述协议的事件流。HTTP

允许从一个存储和事件的拉式检索建模，使用 HTTP/2

“服务器推送”，甚至是连续交付事件流触发

初始请求，但对于事件交付场景，这些技术是

HTTP 的应用，而不是 HTTP 本身的固有特性。

#### 3.2。订阅管理器 API

订阅管理器 API 定义订阅对象和协议
在订阅管理器上创建、更新和删除订阅。
订阅对象描述消费者对事件和定义的兴趣
交付方法。

协议允许在订阅管理器。特别是在发起订阅管理器的情况下
(“推送”风格)交付时，协议用于表达消费者的兴趣
发送到订阅管理器，然后才能启动订阅管理器
交付。

用于配置订阅管理器的协议与传递协议，这意味着应用程序可以配置推送传递
通过 HTTP 发起的 API 调用进入 AMQP 目的地。

原生存在于中间件实现中的订阅管理器可能存在
也有一个单独的 CloudEvents 订阅管理器 API 端点
实现。

如果存在这样一个单独的 API 端点，则创建
订阅在这样一个单独的 API 端点上是不可行的
操作可能不可用。例如，创建 MQTT 订阅是
在 MQTT 连接之外是不可用的，但是现有的订阅可以
可通过订阅集合枚举并删除订阅
可能会终止它。

#### 3.2.1. 订阅对象

订阅管理器管理订阅集合的上限支持多少订阅取决于具体实现。

为了帮助解释订阅资源，下面是非规范伪 Json 显示了它的基本结构:

(`*` 表示零或多个，`+` 表示一个或多个，`?`的意思是可选的)

订阅 :

```
{
  "id": "[订阅管理器作用域的惟一字符串]",
  "source": "[...]", ?
  "types": "[ "[这个类型的值]" + ]", ?
  "config": { ?
    "[key]": [订阅管理器特定值], *
  },

  "filters": [ ?
    { "[方言的名字]": [方言特定的对象] } +
  ],

  "sink": "[传递事件的URI]",
  "protocol": "[交货协议]",
  "protocolsettings": { ?
    "[key]": "[type]", *
  }
}
```

每个订阅由一个具有以下属性的对象表示:

##### id

- 类型:`String`

- 描述:订阅的范围内的唯一标识符订阅管理器的范围内该值必须是惟一的订阅管理器和 MUST 不可变。

- 约束:
  - 检索对象时必需的
  - 如果出现在订阅操作的输入中，则必须忽略它
- 示例:
  - `f1d15fd0-6893-11eb-9439-0242ac130002`
  - `bigco-subscription-1234`

##### source

- 类型:`URI-reference`- 一个 CloudEvents 的源值
- 描述:订阅源的相关信息。
  当出现在订阅请求上时，因此产生的所有事件
  订阅必须有一个与之匹配的 CloudEvents`source`属性
  价值。如果订阅请求中没有此属性，则存在
  是否在 CloudEvents 的`source`属性上没有施加约束
  生成的事件。
  TODO: 在发现中添加一些内容，以指示 manager 是否支持此功能

- 约束:
  - 可选
  - 如果存在，MUST 是非空 URI
- 示例:
  - `/sensors/tn-1234567/alerts`

##### types

- 类型: `Array of Strings' - 数组的 CloudEvents`Type`值
- 描述:用户感兴趣的事件类型在接收当出现在订阅请求时，将生成所有事件由于此订阅必须有一个 CloudEvents 的`type`属性匹配这些值之一。

- 约束:
  - 可选
  - 如果存在，任何存在的值都必须是非空字符串
- 示例:
  - `com.github.pull_request.opened`
  - `com.example.object.deleted`

##### config

- 类型：订阅管理器定义类型的`Map` '
- 描述：一组修改配置的键/值对
  与事件生成过程相关的订阅。虽然这
  规范对映射值的数据类型没有任何限制。
  当存在为订阅管理器，那么 `key` 必须是 `subscriptionconfig` 之一
  发现端点服务定义中指定的键。 `value`
  必须符合由值指定的数据类型
  `key` 的 `subscriptionconfig` 条目

- 约束:
  - 可选
  - 如果存在，映射中使用的任何`key`必须是非空字符串
- 示例:
  - `{ "interval": 5 }`

##### filters

- 类型: `Array of Objects`
- 描述: 一个计算值为 true 或 false 的筛选器表达式数组。
  如果数组中的任何筛选器表达式求值为 false，则事件不可送进水槽。
  如果数组中的所有筛选器表达式的值都为 true，则事件必须尝试交付。
  没有筛选器或空数组意味着值真正的。

  每个过滤器方言必须有一个在过滤器范围内唯一的名称
  订阅管理器。每种方言都会定义其语义和句法
  过滤器表达式语言。请参阅 [Filters](#324-filters) 部分了解
  更多信息。

  如果订阅管理器不支持过滤器，或者过滤器方言
  在订阅请求中指定，那么它必须生成一个错误并且
  拒绝订阅创建或更新请求。

- 约束:
  - 订阅管理者和订阅者都可以选择支持
- 示例:
  - [ {"prefix": { "type": "com.github.issue" } } ]

##### sink

- 类型: `URI`
- 描述: 事件必须发送到的地址。的格式
  地址必须对`protocol`中指定的协议有效
  属性，或协议自己的传输绑定之一（例如 AMQP over
  WebSocket）。

- 约束:
  - 必需
- 示例:
  - `https://example.com/event-processor`

##### sinkCredential

- 类型: 属性图
- 描述: 一组携带凭证信息的设置
  使向订阅目标传递事件的实体能够
  被授权在 `sink` 端点交付。众所周知的
  属性值在 [3.2.3 节](#323-sink-credentials) 中定义。

  实现不应该包括包含在这个映射中的秘密
  订阅对象被枚举或检索。秘密应该是
  只写。令牌、密码和密码就是这样的秘密和
  帐户标识符也可能被视为机密。

- 约束:
  - 可选

##### protocol

- 类型: `String`
- 描述: 交付协议的标识符。因为 WebSocket
  AMQP、MQTT 和其他协议的隧道选项，URI 方案不是
  足以识别协议。具有现有 CloudEvents 的协议
  绑定被标识为`AMQP`、`MQTT3`、`MQTT5`、`HTTP`、`KAFKA`和
  `NATS`。实现可以添加对进一步协议的支持。

- 约束：
  - 必需的
  - 值比较必须区分大小写。
- 示例:
  - `HTTP`

##### 协议设置

- 类型: 协议特定属性的映射
- 描述: 一组特定于所选交付协议的设置
  提供者以下小节列出了这些设置的选项。
  订阅管理器可能会提供更多选项。参见[协议
  Settings](#322-protocol-settings) 部分以获取未来的详细信息。

- 约束:
  - 可选的
- 示例:
  - 证书
  - 重试策略
  - 服务质量模式

一般来说，本规范的目的是考虑处理
事件有 3 个概念阶段：

- 事件生成。此阶段创建事件并通常受控
  通过 `config`、`source` 和 `types` 属性。这可能包括设置
  影响事件产生的频率或事件的范围
  被监控的来源。
- 事件过滤。顾名思义，此阶段将“过滤”流
  上一阶段产生的事件。 **filters**属性将是
  用于指定如何进行此过滤。是否这样做
  独立于事件生成阶段，或作为它的一部分，是
  实施选择。订阅管理器也可以
  通过 **config**属性控制事件流的这一方面，如果他们
  所以选择。
- 事件传输。此阶段控制如何将事件发送到接收器。
  通常，通过处理中的这一步，要发送的事件集是
  已知且唯一的变量是将使用的确切机制
  发送它们。 **protocol**和 **protocolsettings**属性将
  控制这个阶段。

此外，一个订阅属性可能具有
影响事件处理的多个阶段。不管是哪个
订阅的方面由上述哪一项控制
阶段/属性，发现指定的服务描述
规范应该包含足够的信息让消费者知道哪个
创建订阅以获得所需结果时使用的属性。
下面是订阅资源的 JSON 序列化示例：

```JSON
{
  "id": "sub-193-18365",

  "config": {
    "data": "hello",
    "interval": 5
  },

  "filters": [
    { "prefix": { "type": "com.example." } }
  ],

  "protocol": "HTTP",
  "protocolsettings": {
    "method": "POST"
  },
  "sink": "http://example.com/event-processor"
}
```

#### 3.2.2 协议设置

本节列举了特定于协议的交付选项
协议设置映射，必要时包括默认值。

##### 3.2.2.1. HTTP

对于 HTTP，以下设置属性应该被所有人支持
实施。

###### headers

- 类型: `Map`
- 描述：复制到 HTTP 请求中的一组键/值对
  作为自定义标题。
- 约束：
  - 可选的

###### 方法

- 类型: `String`
- 描述：用于发送消息的 HTTP 方法。这个默认
  如果未设置，则发布。
- 约束：
  - 可选的

##### 3.2.2.2. MQTT

所有支持 MQTT 的实现必须支持 _topicname_ 设置。
应该支持所有其他设置。

- **topicname** （字符串）- 必填。要发布到的 MQTT 主题的名称。

###### topicname

- 类型: `String`
- 描述：要发布到的 MQTT 主题的名称。
- 约束：
  - 必需的

###### qos

- 类型: `Integer`
- 描述：MQTT 服务质量 (QoS) 级别：0（最多一次），1（最多一次），1（最多一次）
  至少一次）或 2 次（恰好一次）。如果未设置，则默认为 1。
- 约束：
  - 可选的

###### retain

- 类型: `Boolean`
- 说明：MQTT 保留标志：真/假。如果未设置，则默认为 false。
- 约束：
  - 可选的

###### expiry

- 类型: `Integer`
- 说明：MQTT 过期间隔，以秒为单位。此值没有默认值
  如果设置不存在，则消息不会过期。这个
  设置仅适用于 MQTT 5.0。
- 约束：
  - 可选的

###### userproperties

- 类型: `Map`
- 描述：一组复制到 MQTT PUBLISH 中的键/值对
  数据包的用户属性部分。此设置仅适用于 MQTT 5.0。
- 约束：
  - 可选的

##### 3.2.2.3. AMQP

对于 AMQP，所有实现都必须支持地址属性，并且
所有实现都应该支持其他设置属性。

###### address

- 类型: `String`
- 描述：AMQP 容器中的链接目标节点由
  接收器 URI，如果未在接收器 URI 的路径部分中表示。
- 约束：
  - 可选的

###### linkname

- 类型: `String`
- 描述：用于 AMQP 链接的名称。如果未设置，则随机链接名称
  用来。
- 约束：
  - 可选的

###### sendersettlementmode

- 类型: `String`
- 说明：允许控制发送方的结算方式，即
  确定转账是否“结算”（没有
  确认）或“未解决”（有确认）。默认值为
  不安。
- 约束：
  - 可选的

###### linkproperties

- 类型: `Map`
- 描述：复制到链接属性中的一组键/值对
  对于发送链接。
- 约束：
  - 可选的

##### 3.2.2.4. Apache Kafka

所有支持 Apache Kafka 的实现必须支持 _topicname_
设置。应该支持所有其他设置。

###### topicname

- 类型: `String`
- 描述：要发布到的 Kafka 主题的名称。
- 约束：
  - 可选的

###### partitionkeyextractor

- 类型: `String`
- 描述：每个 CloudEvents Kafka 的分区键提取器表达式
  传输绑定规范。
- 约束：
  - 可选的

###### clientid

- 类型: `String`
- 描述：
- 约束：
  - 可选的

###### acks

- 类型: `String`
- 描述：
- 约束：
  - 可选的

##### 3.2.2.5. NATS

###### 主题

- 类型: `String`
- 描述：要发布到的 NATS 主题的名称。
- 约束： -必需的

#### 3.2.3 接收器凭证

接收器凭据提供必要的身份验证或授权信息
以启用将事件传递到目标。

##### 凭证类型

- 类型: `String`
- 描述：凭证类型的标识符。预定义的类型是“PLAIN”，
  “ACCESSTOKEN”和“REFRESHTOKEN”，下面列举的属性提供
  凭证信息。应用程序可以实现更多的凭证类型。
- 约束:
  - 必需的
- 示例:
  - `PLAIN`

##### identifier

- 类型: String
- 描述：普通凭证的标识符可能是一个帐户或
  用户名。

- 约束:
  - credentialType 需要="PLAIN"

##### secret

- 类型: String
- 描述：普通凭证的秘密可能是密码或
  密码或密钥。

- 约束：
  - credentialType="PLAIN" 需要
  - 在枚举或检索期间不应返回

##### 访问令牌

- 类型: String
- 描述：访问令牌是先前获得的授予访问权限的令牌
  目标资源。

- 约束：
  - credentialType="ACCESSTOKEN" 和 credentialType="REFRESHTOKEN" 需要
  - 在枚举或检索期间不应返回

##### 访问令牌过期 UTC

- 类型：时间戳
- 描述：应考虑令牌的绝对 UTC 时刻
  已到期。

- 约束:
  - REQUIRED for credentialType="ACCESSTOKEN" and credentialType="REFRESHTOKEN"

##### 访问令牌类型

- 类型: String
- 描述: 访问令牌的类型（请参阅 [OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-7.1)）。

- 约束:
  - REQUIRED for credentialType="ACCESSTOKEN" and credentialType="REFRESHTOKEN"

##### 刷新令牌

- 类型：字符串
- 描述：用于获取访问令牌的刷新令牌凭证。

- 约束:
  - REQUIRED for credentialType="REFRESHTOKEN"

##### 刷新令牌端点

- 类型：字符串
- 描述：可以用刷新令牌换取访问权的 URL
  令牌。

  并不是说在某些设置中，访问刷新令牌端点会使用额外的
  安全层，请求者将刷新令牌传递给
  端点必须被授权。此授权的凭据
  关系，存在于所管理的交付服务之间
  订阅 API 和刷新端点不在此范围内
  规格。 sinkCredentials 代表授权关系
  在订阅者和它指向订阅的交付目标之间。

#### 3.2.4 Filters

过滤器允许订阅指定仅事件的子集
根据一组标准将其传送到接收器。 a 中的`filter`属性
订阅是一组过滤器表达式，其中每个表达式的计算结果为
对于生成的每个事件，要么为真，要么为假。

如果集合中的任何过滤器表达式计算结果为 false，则事件必须
不要被送到水槽。如果集合中的所有过滤器表达式计算为
true，必须尝试传递事件。

每个过滤器表达式都包含一个“方言”的规范
定义过滤器的类型和附加属性集
在过滤器表达式中允许。如果在
订阅管理器不支持的订阅，创建或
订阅的更新必须因错误而被拒绝。

##### 3.2.4.1 Filter Dialects

事件生成器支持的过滤器表达式语言由
它的方言。这是为了允许灵活性、可扩展性和
允许各种过滤方言，而无需在此一一列举
规范或预测每个系统在
未来。

过滤器方言由唯一的“URI-Reference”标识。

当以 JSON 编码时，过滤器编码如下：

```
{ "dialect URI-Reference" : { <dialect-specific-properties> } }
```

本规范定义了以下 7 种过滤方言
实现必须支持：

###### `exact` filter dialect

键是要匹配的 CloudEvents 属性的名称，
它们的值是要在比较中使用的字符串值。
要将匹配的 CloudEvents 属性的值评估为真，必须
all 与指定的关联值 String 完全匹配（区分大小写）。

过滤器表达式中指定的属性名称和值不得为
空字符串。

例如：

```json
{
  "exact": {
    "type": "com.github.push",
    "subject": "https://github.com/cloudevents/spec"
  }
}
```

###### `prefix` filter dialect

键是要匹配的 CloudEvents 属性的名称，
它们的值是要在比较中使用的字符串值。
要将匹配的 CloudEvents 属性的值评估为真，必须
所有都以指定的关联值字符串开头（区分大小写）。

过滤器表达式中指定的属性名称和值不得为
空字符串。

例如：

```json
{
  "prefix": {
    "type": "com.github.",
    "subject": "https://github.com/cloudevents"
  }
}
```

###### `suffix` filter dialect

键是要匹配的 CloudEvents 属性的名称，
它们的值是要在比较中使用的字符串值。
要将匹配的 CloudEvents 属性的值评估为真，必须
全部以指定的关联值字符串结尾（区分大小写）。

过滤器表达式中指定的属性名称和值不得为
空字符串。

例如：

```json
{ "suffix": { "type": ".created", "subject": "/cloudevents/spec" } }
```

###### `all` filter dialect

使用这个必须包括一个嵌套的过滤器表达式数组，其中所有
嵌套过滤器表达式必须评估为真才能为“所有”
过滤表达式为真。

注意：数组中必须至少有一个过滤器表达式。

例如：

```json
{
  "all": [
    { "exact": { "type": "com.github.push" } },
    { "exact": { "subject": "https://github.com/cloudevents/spec" } }
  ]
}
```

###### `any` filter dialect

对此的使用必须包括一个嵌套的过滤器表达式数组，其中至少
一个嵌套的过滤器表达式必须计算为真，以便为 `any`
过滤表达式为真。

注意：数组中必须至少有一个过滤器表达式。

例如：

```json
{
  "any": [
    { "exact": { "type": "com.github.push" } },
    { "exact": { "subject": "https://github.com/cloudevents/spec" } }
  ]
}
```

###### `not` filter dialect

this 的使用必须包含一个嵌套过滤器表达式，其中 this 的结果
过滤器表达式是嵌套表达式结果的倒数。
换句话说，如果嵌套表达式的计算结果为真，那么 `not`
过滤器表达式的结果为假。

例如：

```json
{
  "not": { "exact": { "type": "com.github.push" } }
}
```

###### `sql` filter dialect

使用此必须有一个字符串值，表示 [CloudEvents SQL 表达式](../cesql/spec.md)。
如果表达式的结果值（强制为布尔值）等于“TRUE”布尔值，则过滤器结果必须为真，
否则，如果在评估表达式时发生错误或结果值，则必须为 false，
强制为布尔值，等于“FALSE”布尔值。

实现应该拒绝带有无效 CloudEvents SQL 表达式的订阅。

```json
{ "sql": "source LIKE '%cloudevents%'" }
```

#### 3.2.5. API 操作

本节列举了为
订阅管理员。以下部分定义了这些抽象的绑定
具体协议的操作。

操作是`Create`, `Retrieve`, `Query`, `Update`。的
那些，只有 `Retrieve` 操作是符合要求的。`Create`
和 `Delete` 操作应该被实现。 `Query` 和 `Update` 是
可选的。
协议绑定应该提供一种发现机制支持的。

#### 3.2.5.1. 创建订阅

**Create**操作应该由兼容的事件生产者支持。它
创建一个新的订阅。客户端提出一个订阅对象，它必须
包含所有必需的属性，但 `ID` 属性除外，它
将由订阅管理器定义。然后订阅管理器
实现订阅并返回一个订阅对象，该对象还包含
已应用默认值的所有可选属性。

参数：

- 订阅（订阅） -需要。提议的订阅对象。
  结果：

- 订阅（订阅） -需要。实现订阅对象。

错误：

- **ok** - 操作成功
- **conflict** - 具有给定 _id_ 的订阅已经存在
- **invalid** - 提议的订阅对象包含无效信息

协议绑定可以映射 Create 操作，使得提议的 _id_ 是
被忽略，订阅管理器改为分配一个。

#### 3.2.5.2. 检索订阅

**Retrieve**操作必须由兼容的事件生产者支持。它
返回已识别订阅的规范。

参数：

- id（字符串） - 必需的。订阅的标识符。

结果：

- 订阅（订阅） - 需要。订阅对象。

错误：

- **ok**-操作成功
- **notfound**-具有给定 _id_ 的订阅已经存在

#### 3.2.5.3. 查询订阅列表

**Query**操作应该由兼容的事件生产者支持。它
允许在关联的订阅管理器上查询订阅列表
与提出请求的一方可见或以其他方式可见。如果支持，它必须
在与 **Create**订阅操作相同的端点上得到支持。

参数：

- 没有任何

结果：

- 订阅（订阅列表） -必需的。订阅对象列表

错误：

- **ok**-操作成功并返回结果
- **nocontent**-操作成功并且没有返回结果

协议绑定和此类绑定的实现可以添加自定义过滤器
约束和分页参数作为参数。没有过滤的请求
约束应该返回与或关联的所有可用订阅
以其他方式对提出请求的一方可见。

#### 3.2.5.4. 更新订阅

更新操作可能由兼容的事件生产者支持。请求
一个订阅的更新，客户端提交一个提议的订阅对象
其 _id_ 必须与现有订阅匹配。所有其他属性可能不同
从原始订阅。然后订阅管理器更新
订阅并返回一个订阅对象，该对象还包含所有 OPTIONAL
已应用默认值的属性。

参数：

- 订阅（订阅） - 需要。提议的订阅对象。

结果：

- 订阅（订阅） - 需要。实现订阅对象。

协议绑定可以将更新和创建操作映射到一个组合中
如果订阅具有给定的*id*，则创建新订阅的“upsert”操作
不存在。在这种情况下，操作是 \*_Create_ 并遵循
操作的规则。

#### 3.2.5.5. 删除订阅

**Delete**操作应该由兼容的事件生产者支持。它
返回已识别订阅的规范。

参数:

- id（字符串）-必需的。订阅的标识符。

结果:

- 订阅（订阅） - 必需的。订阅对象。

错误:

- **ok** - 操作成功
- **notfound** - 具有给定 _id_ 的订阅已存在

### 3.3. 订阅 API 的 HTTP 绑定

（待定）这将是描述的 API 到基本 API 的直接映射
使用 PUT、POST、GET、DELETE 和 OPTIONS 的 HTTP CRUD API。

占位符:

```
创建:
POST /subscriptions
Content-类型: application/json

{
  "config": { ... }
  "filter": { ... },
  "protocol": "...",
  "protocolsettings": { ... },
  "sink": "..."
}

Note: 请求中没有 ID

获取:
GET /subscriptions/{id}

删除:
DELETE /subscriptions/{id}

更新:
PUT /subscriptions/{id}
Content-类型: application/json

{
  "id": "...",
  "config": { ... }
  "filter": { ... },
  "protocol": "...",
  "protocolsettings": { ... },
  "sink": "..."
}

```

### 3.4. 订阅 API 的 AMQP 绑定

（待定）这将是一组针对各自的双向交换
操作。

## 4. 一致性

（待定）一致性条款。
